// Generated by gencpp from file rover_pkg/SensorData.msg
// DO NOT EDIT!


#ifndef ROVER_PKG_MESSAGE_SENSORDATA_H
#define ROVER_PKG_MESSAGE_SENSORDATA_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace rover_pkg
{
template <class ContainerAllocator>
struct SensorData_
{
  typedef SensorData_<ContainerAllocator> Type;

  SensorData_()
    : pressure(0)
    , rbl_temp(0)
    , rbr_temp(0)
    , bmp280_temp(0)
    , st_set(false)
    , st_index(false)
    , v_csense(0)
    , v_vsense(0)
    , rb_fr_vel(0)
    , rb_fr_pos(0)
    , rb_mr_vel(0)
    , rb_mr_pos(0)
    , rb_rr_vel(0)
    , rb_rr_pos(0)
    , rb_fl_vel(0)
    , rb_fl_pos(0)
    , rb_ml_vel(0)
    , rb_ml_pos(0)
    , rb_rl_vel(0)
    , rb_rl_pos(0)
    , rb_rb_sig(0)
    , rb_lb_sig(0)
    , rb_da_sig(0)
    , table_sig(0)
    , bd_sig(0)
    , ad_sig(0)
    , wpd_sig(0)
    , wrd_sig(0)
    , chss_gpio1(false)
    , chss_gpio2(false)
    , chss_gpio3(false)
    , chss_gpio4(false)
    , chss_gpio5(false)
    , chss_gpio6(false)
    , gx(0.0)
    , gy(0.0)
    , gz(0.0)
    , ax(0.0)
    , ay(0.0)
    , az(0.0)
    , mx(0.0)
    , my(0.0)
    , mz(0.0)  {
    }
  SensorData_(const ContainerAllocator& _alloc)
    : pressure(0)
    , rbl_temp(0)
    , rbr_temp(0)
    , bmp280_temp(0)
    , st_set(false)
    , st_index(false)
    , v_csense(0)
    , v_vsense(0)
    , rb_fr_vel(0)
    , rb_fr_pos(0)
    , rb_mr_vel(0)
    , rb_mr_pos(0)
    , rb_rr_vel(0)
    , rb_rr_pos(0)
    , rb_fl_vel(0)
    , rb_fl_pos(0)
    , rb_ml_vel(0)
    , rb_ml_pos(0)
    , rb_rl_vel(0)
    , rb_rl_pos(0)
    , rb_rb_sig(0)
    , rb_lb_sig(0)
    , rb_da_sig(0)
    , table_sig(0)
    , bd_sig(0)
    , ad_sig(0)
    , wpd_sig(0)
    , wrd_sig(0)
    , chss_gpio1(false)
    , chss_gpio2(false)
    , chss_gpio3(false)
    , chss_gpio4(false)
    , chss_gpio5(false)
    , chss_gpio6(false)
    , gx(0.0)
    , gy(0.0)
    , gz(0.0)
    , ax(0.0)
    , ay(0.0)
    , az(0.0)
    , mx(0.0)
    , my(0.0)
    , mz(0.0)  {
  (void)_alloc;
    }



   typedef int32_t _pressure_type;
  _pressure_type pressure;

   typedef int32_t _rbl_temp_type;
  _rbl_temp_type rbl_temp;

   typedef int32_t _rbr_temp_type;
  _rbr_temp_type rbr_temp;

   typedef int32_t _bmp280_temp_type;
  _bmp280_temp_type bmp280_temp;

   typedef uint8_t _st_set_type;
  _st_set_type st_set;

   typedef uint8_t _st_index_type;
  _st_index_type st_index;

   typedef int32_t _v_csense_type;
  _v_csense_type v_csense;

   typedef int32_t _v_vsense_type;
  _v_vsense_type v_vsense;

   typedef int32_t _rb_fr_vel_type;
  _rb_fr_vel_type rb_fr_vel;

   typedef int32_t _rb_fr_pos_type;
  _rb_fr_pos_type rb_fr_pos;

   typedef int32_t _rb_mr_vel_type;
  _rb_mr_vel_type rb_mr_vel;

   typedef int32_t _rb_mr_pos_type;
  _rb_mr_pos_type rb_mr_pos;

   typedef int32_t _rb_rr_vel_type;
  _rb_rr_vel_type rb_rr_vel;

   typedef int32_t _rb_rr_pos_type;
  _rb_rr_pos_type rb_rr_pos;

   typedef int32_t _rb_fl_vel_type;
  _rb_fl_vel_type rb_fl_vel;

   typedef int32_t _rb_fl_pos_type;
  _rb_fl_pos_type rb_fl_pos;

   typedef int32_t _rb_ml_vel_type;
  _rb_ml_vel_type rb_ml_vel;

   typedef int32_t _rb_ml_pos_type;
  _rb_ml_pos_type rb_ml_pos;

   typedef int32_t _rb_rl_vel_type;
  _rb_rl_vel_type rb_rl_vel;

   typedef int32_t _rb_rl_pos_type;
  _rb_rl_pos_type rb_rl_pos;

   typedef int32_t _rb_rb_sig_type;
  _rb_rb_sig_type rb_rb_sig;

   typedef int32_t _rb_lb_sig_type;
  _rb_lb_sig_type rb_lb_sig;

   typedef int32_t _rb_da_sig_type;
  _rb_da_sig_type rb_da_sig;

   typedef int32_t _table_sig_type;
  _table_sig_type table_sig;

   typedef int32_t _bd_sig_type;
  _bd_sig_type bd_sig;

   typedef int32_t _ad_sig_type;
  _ad_sig_type ad_sig;

   typedef int32_t _wpd_sig_type;
  _wpd_sig_type wpd_sig;

   typedef int32_t _wrd_sig_type;
  _wrd_sig_type wrd_sig;

   typedef uint8_t _chss_gpio1_type;
  _chss_gpio1_type chss_gpio1;

   typedef uint8_t _chss_gpio2_type;
  _chss_gpio2_type chss_gpio2;

   typedef uint8_t _chss_gpio3_type;
  _chss_gpio3_type chss_gpio3;

   typedef uint8_t _chss_gpio4_type;
  _chss_gpio4_type chss_gpio4;

   typedef uint8_t _chss_gpio5_type;
  _chss_gpio5_type chss_gpio5;

   typedef uint8_t _chss_gpio6_type;
  _chss_gpio6_type chss_gpio6;

   typedef float _gx_type;
  _gx_type gx;

   typedef float _gy_type;
  _gy_type gy;

   typedef float _gz_type;
  _gz_type gz;

   typedef float _ax_type;
  _ax_type ax;

   typedef float _ay_type;
  _ay_type ay;

   typedef float _az_type;
  _az_type az;

   typedef float _mx_type;
  _mx_type mx;

   typedef float _my_type;
  _my_type my;

   typedef float _mz_type;
  _mz_type mz;





  typedef boost::shared_ptr< ::rover_pkg::SensorData_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::rover_pkg::SensorData_<ContainerAllocator> const> ConstPtr;

}; // struct SensorData_

typedef ::rover_pkg::SensorData_<std::allocator<void> > SensorData;

typedef boost::shared_ptr< ::rover_pkg::SensorData > SensorDataPtr;
typedef boost::shared_ptr< ::rover_pkg::SensorData const> SensorDataConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::rover_pkg::SensorData_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::rover_pkg::SensorData_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::rover_pkg::SensorData_<ContainerAllocator1> & lhs, const ::rover_pkg::SensorData_<ContainerAllocator2> & rhs)
{
  return lhs.pressure == rhs.pressure &&
    lhs.rbl_temp == rhs.rbl_temp &&
    lhs.rbr_temp == rhs.rbr_temp &&
    lhs.bmp280_temp == rhs.bmp280_temp &&
    lhs.st_set == rhs.st_set &&
    lhs.st_index == rhs.st_index &&
    lhs.v_csense == rhs.v_csense &&
    lhs.v_vsense == rhs.v_vsense &&
    lhs.rb_fr_vel == rhs.rb_fr_vel &&
    lhs.rb_fr_pos == rhs.rb_fr_pos &&
    lhs.rb_mr_vel == rhs.rb_mr_vel &&
    lhs.rb_mr_pos == rhs.rb_mr_pos &&
    lhs.rb_rr_vel == rhs.rb_rr_vel &&
    lhs.rb_rr_pos == rhs.rb_rr_pos &&
    lhs.rb_fl_vel == rhs.rb_fl_vel &&
    lhs.rb_fl_pos == rhs.rb_fl_pos &&
    lhs.rb_ml_vel == rhs.rb_ml_vel &&
    lhs.rb_ml_pos == rhs.rb_ml_pos &&
    lhs.rb_rl_vel == rhs.rb_rl_vel &&
    lhs.rb_rl_pos == rhs.rb_rl_pos &&
    lhs.rb_rb_sig == rhs.rb_rb_sig &&
    lhs.rb_lb_sig == rhs.rb_lb_sig &&
    lhs.rb_da_sig == rhs.rb_da_sig &&
    lhs.table_sig == rhs.table_sig &&
    lhs.bd_sig == rhs.bd_sig &&
    lhs.ad_sig == rhs.ad_sig &&
    lhs.wpd_sig == rhs.wpd_sig &&
    lhs.wrd_sig == rhs.wrd_sig &&
    lhs.chss_gpio1 == rhs.chss_gpio1 &&
    lhs.chss_gpio2 == rhs.chss_gpio2 &&
    lhs.chss_gpio3 == rhs.chss_gpio3 &&
    lhs.chss_gpio4 == rhs.chss_gpio4 &&
    lhs.chss_gpio5 == rhs.chss_gpio5 &&
    lhs.chss_gpio6 == rhs.chss_gpio6 &&
    lhs.gx == rhs.gx &&
    lhs.gy == rhs.gy &&
    lhs.gz == rhs.gz &&
    lhs.ax == rhs.ax &&
    lhs.ay == rhs.ay &&
    lhs.az == rhs.az &&
    lhs.mx == rhs.mx &&
    lhs.my == rhs.my &&
    lhs.mz == rhs.mz;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::rover_pkg::SensorData_<ContainerAllocator1> & lhs, const ::rover_pkg::SensorData_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace rover_pkg

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::rover_pkg::SensorData_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::rover_pkg::SensorData_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::rover_pkg::SensorData_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::rover_pkg::SensorData_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::rover_pkg::SensorData_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::rover_pkg::SensorData_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::rover_pkg::SensorData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "6d8c06323fba8db66de6bea5d0e4ef77";
  }

  static const char* value(const ::rover_pkg::SensorData_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x6d8c06323fba8db6ULL;
  static const uint64_t static_value2 = 0x6de6bea5d0e4ef77ULL;
};

template<class ContainerAllocator>
struct DataType< ::rover_pkg::SensorData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "rover_pkg/SensorData";
  }

  static const char* value(const ::rover_pkg::SensorData_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::rover_pkg::SensorData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int32 pressure\n"
"int32 rbl_temp\n"
"int32 rbr_temp\n"
"int32 bmp280_temp\n"
"\n"
"bool st_set\n"
"bool st_index\n"
"\n"
"int32 v_csense\n"
"int32 v_vsense\n"
"\n"
"int32 rb_fr_vel\n"
"int32 rb_fr_pos\n"
"int32 rb_mr_vel\n"
"int32 rb_mr_pos\n"
"int32 rb_rr_vel\n"
"int32 rb_rr_pos\n"
"\n"
"int32 rb_fl_vel\n"
"int32 rb_fl_pos\n"
"int32 rb_ml_vel\n"
"int32 rb_ml_pos\n"
"int32 rb_rl_vel\n"
"int32 rb_rl_pos\n"
"\n"
"int32 rb_rb_sig\n"
"int32 rb_lb_sig\n"
"int32 rb_da_sig\n"
"\n"
"int32 table_sig\n"
"int32 bd_sig\n"
"int32 ad_sig\n"
"int32 wpd_sig\n"
"int32 wrd_sig\n"
"\n"
"bool chss_gpio1\n"
"bool chss_gpio2\n"
"bool chss_gpio3\n"
"bool chss_gpio4\n"
"bool chss_gpio5\n"
"bool chss_gpio6\n"
"\n"
"float32 gx\n"
"float32 gy\n"
"float32 gz\n"
"\n"
"float32 ax\n"
"float32 ay\n"
"float32 az\n"
"\n"
"float32 mx\n"
"float32 my\n"
"float32 mz\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
;
  }

  static const char* value(const ::rover_pkg::SensorData_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::rover_pkg::SensorData_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.pressure);
      stream.next(m.rbl_temp);
      stream.next(m.rbr_temp);
      stream.next(m.bmp280_temp);
      stream.next(m.st_set);
      stream.next(m.st_index);
      stream.next(m.v_csense);
      stream.next(m.v_vsense);
      stream.next(m.rb_fr_vel);
      stream.next(m.rb_fr_pos);
      stream.next(m.rb_mr_vel);
      stream.next(m.rb_mr_pos);
      stream.next(m.rb_rr_vel);
      stream.next(m.rb_rr_pos);
      stream.next(m.rb_fl_vel);
      stream.next(m.rb_fl_pos);
      stream.next(m.rb_ml_vel);
      stream.next(m.rb_ml_pos);
      stream.next(m.rb_rl_vel);
      stream.next(m.rb_rl_pos);
      stream.next(m.rb_rb_sig);
      stream.next(m.rb_lb_sig);
      stream.next(m.rb_da_sig);
      stream.next(m.table_sig);
      stream.next(m.bd_sig);
      stream.next(m.ad_sig);
      stream.next(m.wpd_sig);
      stream.next(m.wrd_sig);
      stream.next(m.chss_gpio1);
      stream.next(m.chss_gpio2);
      stream.next(m.chss_gpio3);
      stream.next(m.chss_gpio4);
      stream.next(m.chss_gpio5);
      stream.next(m.chss_gpio6);
      stream.next(m.gx);
      stream.next(m.gy);
      stream.next(m.gz);
      stream.next(m.ax);
      stream.next(m.ay);
      stream.next(m.az);
      stream.next(m.mx);
      stream.next(m.my);
      stream.next(m.mz);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct SensorData_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::rover_pkg::SensorData_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::rover_pkg::SensorData_<ContainerAllocator>& v)
  {
    s << indent << "pressure: ";
    Printer<int32_t>::stream(s, indent + "  ", v.pressure);
    s << indent << "rbl_temp: ";
    Printer<int32_t>::stream(s, indent + "  ", v.rbl_temp);
    s << indent << "rbr_temp: ";
    Printer<int32_t>::stream(s, indent + "  ", v.rbr_temp);
    s << indent << "bmp280_temp: ";
    Printer<int32_t>::stream(s, indent + "  ", v.bmp280_temp);
    s << indent << "st_set: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.st_set);
    s << indent << "st_index: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.st_index);
    s << indent << "v_csense: ";
    Printer<int32_t>::stream(s, indent + "  ", v.v_csense);
    s << indent << "v_vsense: ";
    Printer<int32_t>::stream(s, indent + "  ", v.v_vsense);
    s << indent << "rb_fr_vel: ";
    Printer<int32_t>::stream(s, indent + "  ", v.rb_fr_vel);
    s << indent << "rb_fr_pos: ";
    Printer<int32_t>::stream(s, indent + "  ", v.rb_fr_pos);
    s << indent << "rb_mr_vel: ";
    Printer<int32_t>::stream(s, indent + "  ", v.rb_mr_vel);
    s << indent << "rb_mr_pos: ";
    Printer<int32_t>::stream(s, indent + "  ", v.rb_mr_pos);
    s << indent << "rb_rr_vel: ";
    Printer<int32_t>::stream(s, indent + "  ", v.rb_rr_vel);
    s << indent << "rb_rr_pos: ";
    Printer<int32_t>::stream(s, indent + "  ", v.rb_rr_pos);
    s << indent << "rb_fl_vel: ";
    Printer<int32_t>::stream(s, indent + "  ", v.rb_fl_vel);
    s << indent << "rb_fl_pos: ";
    Printer<int32_t>::stream(s, indent + "  ", v.rb_fl_pos);
    s << indent << "rb_ml_vel: ";
    Printer<int32_t>::stream(s, indent + "  ", v.rb_ml_vel);
    s << indent << "rb_ml_pos: ";
    Printer<int32_t>::stream(s, indent + "  ", v.rb_ml_pos);
    s << indent << "rb_rl_vel: ";
    Printer<int32_t>::stream(s, indent + "  ", v.rb_rl_vel);
    s << indent << "rb_rl_pos: ";
    Printer<int32_t>::stream(s, indent + "  ", v.rb_rl_pos);
    s << indent << "rb_rb_sig: ";
    Printer<int32_t>::stream(s, indent + "  ", v.rb_rb_sig);
    s << indent << "rb_lb_sig: ";
    Printer<int32_t>::stream(s, indent + "  ", v.rb_lb_sig);
    s << indent << "rb_da_sig: ";
    Printer<int32_t>::stream(s, indent + "  ", v.rb_da_sig);
    s << indent << "table_sig: ";
    Printer<int32_t>::stream(s, indent + "  ", v.table_sig);
    s << indent << "bd_sig: ";
    Printer<int32_t>::stream(s, indent + "  ", v.bd_sig);
    s << indent << "ad_sig: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ad_sig);
    s << indent << "wpd_sig: ";
    Printer<int32_t>::stream(s, indent + "  ", v.wpd_sig);
    s << indent << "wrd_sig: ";
    Printer<int32_t>::stream(s, indent + "  ", v.wrd_sig);
    s << indent << "chss_gpio1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.chss_gpio1);
    s << indent << "chss_gpio2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.chss_gpio2);
    s << indent << "chss_gpio3: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.chss_gpio3);
    s << indent << "chss_gpio4: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.chss_gpio4);
    s << indent << "chss_gpio5: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.chss_gpio5);
    s << indent << "chss_gpio6: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.chss_gpio6);
    s << indent << "gx: ";
    Printer<float>::stream(s, indent + "  ", v.gx);
    s << indent << "gy: ";
    Printer<float>::stream(s, indent + "  ", v.gy);
    s << indent << "gz: ";
    Printer<float>::stream(s, indent + "  ", v.gz);
    s << indent << "ax: ";
    Printer<float>::stream(s, indent + "  ", v.ax);
    s << indent << "ay: ";
    Printer<float>::stream(s, indent + "  ", v.ay);
    s << indent << "az: ";
    Printer<float>::stream(s, indent + "  ", v.az);
    s << indent << "mx: ";
    Printer<float>::stream(s, indent + "  ", v.mx);
    s << indent << "my: ";
    Printer<float>::stream(s, indent + "  ", v.my);
    s << indent << "mz: ";
    Printer<float>::stream(s, indent + "  ", v.mz);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ROVER_PKG_MESSAGE_SENSORDATA_H
